#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Passenger Generation Engine

Uses passenger model data to generate realistic passenger flows with real-time factors.
Integrates with the dynamic model loader for data-driven passenger simulation.
"""

import datetime
import random
import math
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass, field

# Use standard json instead of jsonschema for validation
import json


@dataclass
class GeneratedPassenger:
    """Individual passenger generated by the system."""
    passenger_id: str
    location_id: str
    action: str  # "board" or "alight"
    timestamp: datetime.datetime
    trip_purpose: str
    wait_time_seconds: int = 0
    boarding_time_seconds: int = 3
    destination_stop: Optional[str] = None
    fare_type: str = "regular"


@dataclass
class PassengerBatch:
    """Batch of passengers for a specific time/location."""
    location_id: str
    timestamp: datetime.datetime
    boarding_passengers: List[GeneratedPassenger] = field(default_factory=list)
    alighting_passengers: List[GeneratedPassenger] = field(default_factory=list)
    total_boarding: int = 0
    total_alighting: int = 0
    applied_factors: Dict[str, float] = field(default_factory=dict)


class PassengerGenerationEngine:
    """Engine for generating realistic passenger flows from model data."""
    
    def __init__(self, model_loader=None):
        # Import the model loader (avoid circular imports)
        if model_loader is None:
            try:
                from .passenger_model_loader import passenger_model_loader
                self.model_loader = passenger_model_loader
            except ImportError:
                print("âš ï¸ Could not import passenger_model_loader - using mock loader")
                self.model_loader = None
        else:
            self.model_loader = model_loader
        
        self.passenger_counter = 0
        self.generated_batches: List[PassengerBatch] = []
        self.active_passengers: Dict[str, GeneratedPassenger] = {}
        
        # Configuration
        self.max_total_passengers = 50  # Global passenger limit
        self.boarding_time_range = (2, 5)  # seconds
        self.max_wait_time = 900  # 15 minutes in seconds
    
    def set_passenger_limit(self, max_passengers: int) -> None:
        """Set maximum total passenger count."""
        self.max_total_passengers = max_passengers
        print(f"ðŸšŒ Set passenger limit to {max_passengers}")
    
    def generate_passenger_batch(self, 
                                model_name: str,
                                location_id: str,
                                target_time: datetime.datetime,
                                duration_minutes: int = 30) -> Optional[PassengerBatch]:
        """Generate a batch of passengers for specific location and time."""
        
        if not self.model_loader:
            return self._generate_simple_batch(location_id, target_time, duration_minutes)
        
        # Calculate passenger flow using model
        flow_result = self.model_loader.calculate_passenger_flow(
            model_name, location_id, target_time, duration_minutes
        )
        
        if not flow_result:
            return None
        
        # Check passenger limits
        current_passenger_count = len(self.active_passengers)
        available_slots = max(0, self.max_total_passengers - current_passenger_count)
        
        # Adjust expected counts based on available capacity
        max_boarding = min(flow_result.expected_boarding_count, available_slots)
        max_alighting = min(flow_result.expected_alighting_count, 
                           len([p for p in self.active_passengers.values() 
                               if p.location_id == location_id and p.action == "board"]))
        
        # Generate passenger batch
        batch = PassengerBatch(
            location_id=location_id,
            timestamp=target_time,
            applied_factors=flow_result.applied_factors
        )
        
        # Generate boarding passengers
        boarding_passengers = self._generate_boarding_passengers(
            location_id, target_time, max_boarding, flow_result.trip_purposes
        )
        batch.boarding_passengers = boarding_passengers
        batch.total_boarding = len(boarding_passengers)
        
        # Generate alighting passengers
        alighting_passengers = self._generate_alighting_passengers(
            location_id, target_time, max_alighting
        )
        batch.alighting_passengers = alighting_passengers
        batch.total_alighting = len(alighting_passengers)
        
        # Store batch for tracking
        self.generated_batches.append(batch)
        
        # Update active passengers
        for passenger in boarding_passengers:
            self.active_passengers[passenger.passenger_id] = passenger
        
        for passenger in alighting_passengers:
            if passenger.passenger_id in self.active_passengers:
                del self.active_passengers[passenger.passenger_id]
        
        print(f"ðŸš¶ Generated batch for {location_id}: "
              f"{batch.total_boarding} boarding, {batch.total_alighting} alighting "
              f"(Total active: {len(self.active_passengers)})")
        
        return batch
    
    def _generate_boarding_passengers(self, 
                                    location_id: str,
                                    timestamp: datetime.datetime,
                                    count: int,
                                    trip_purposes: Dict[str, float]) -> List[GeneratedPassenger]:
        """Generate boarding passengers with trip purposes."""
        passengers = []
        
        for _ in range(count):
            passenger_id = f"PAX_{self.passenger_counter:06d}"
            self.passenger_counter += 1
            
            # Select trip purpose based on probabilities
            trip_purpose = self._select_trip_purpose(trip_purposes)
            
            # Generate boarding characteristics
            boarding_time = random.randint(*self.boarding_time_range)
            wait_time = random.randint(0, min(300, self.max_wait_time))  # Max 5 min wait
            
            # Determine fare type (simplified)
            fare_type = self._determine_fare_type(trip_purpose, timestamp)
            
            passenger = GeneratedPassenger(
                passenger_id=passenger_id,
                location_id=location_id,
                action="board",
                timestamp=timestamp,
                trip_purpose=trip_purpose,
                wait_time_seconds=wait_time,
                boarding_time_seconds=boarding_time,
                fare_type=fare_type
            )
            
            passengers.append(passenger)
        
        return passengers
    
    def _generate_alighting_passengers(self,
                                     location_id: str,
                                     timestamp: datetime.datetime,
                                     count: int) -> List[GeneratedPassenger]:
        """Generate alighting passengers from currently active passengers."""
        passengers = []
        
        # Find candidates for alighting at this location
        candidates = [p for p in self.active_passengers.values() 
                     if p.action == "board"]
        
        if not candidates:
            return passengers
        
        # Select passengers to alight (random selection for now)
        alighting_count = min(count, len(candidates))
        selected_passengers = random.sample(candidates, alighting_count)
        
        for passenger in selected_passengers:
            alighting_passenger = GeneratedPassenger(
                passenger_id=passenger.passenger_id,
                location_id=location_id,
                action="alight",
                timestamp=timestamp,
                trip_purpose=passenger.trip_purpose,
                boarding_time_seconds=random.randint(1, 3),  # Exit time
                fare_type=passenger.fare_type
            )
            passengers.append(alighting_passenger)
        
        return passengers
    
    def _select_trip_purpose(self, trip_purposes: Dict[str, float]) -> str:
        """Select trip purpose based on probability distribution."""
        if not trip_purposes:
            return "general"
        
        # Create weighted selection
        purposes = list(trip_purposes.keys())
        weights = list(trip_purposes.values())
        
        # Normalize weights
        total_weight = sum(weights)
        if total_weight == 0:
            return random.choice(purposes)
        
        normalized_weights = [w / total_weight for w in weights]
        
        # Random selection based on weights
        rand_val = random.random()
        cumulative = 0
        
        for purpose, weight in zip(purposes, normalized_weights):
            cumulative += weight
            if rand_val <= cumulative:
                return purpose
        
        return purposes[-1]  # Fallback
    
    def _determine_fare_type(self, trip_purpose: str, timestamp: datetime.datetime) -> str:
        """Determine fare type based on trip purpose and time."""
        # Simplified fare type logic
        if trip_purpose in ["education", "school"]:
            return "student"
        elif timestamp.hour >= 65 or timestamp.hour <= 6:  # Senior hours
            return "senior"
        elif trip_purpose == "medical":
            return "concession"
        else:
            return "regular"
    
    def _generate_simple_batch(self,
                             location_id: str,
                             target_time: datetime.datetime,
                             duration_minutes: int) -> PassengerBatch:
        """Generate simple passenger batch without model data."""
        # Fallback generation when model loader is not available
        current_count = len(self.active_passengers)
        available_slots = max(0, self.max_total_passengers - current_count)
        
        # Simple time-based generation
        is_peak = self._is_simple_peak_time(target_time)
        base_rate = 8 if is_peak else 3  # passengers per hour
        
        duration_hours = duration_minutes / 60.0
        expected_count = int(base_rate * duration_hours)
        actual_count = min(expected_count, available_slots)
        
        batch = PassengerBatch(
            location_id=location_id,
            timestamp=target_time
        )
        
        # Generate simple boarding passengers
        for i in range(actual_count):
            passenger_id = f"PAX_{self.passenger_counter:06d}"
            self.passenger_counter += 1
            
            passenger = GeneratedPassenger(
                passenger_id=passenger_id,
                location_id=location_id,
                action="board",
                timestamp=target_time,
                trip_purpose="general",
                wait_time_seconds=random.randint(30, 180),
                boarding_time_seconds=random.randint(2, 4)
            )
            
            batch.boarding_passengers.append(passenger)
            self.active_passengers[passenger_id] = passenger
        
        batch.total_boarding = actual_count
        batch.total_alighting = 0  # Simplified - no alighting
        
        print(f"ðŸš¶ Generated simple batch for {location_id}: {actual_count} passengers")
        return batch
    
    def _is_simple_peak_time(self, timestamp: datetime.datetime) -> bool:
        """Simple peak time detection."""
        hour = timestamp.hour
        weekday = timestamp.weekday()
        
        if weekday >= 5:  # Weekend
            return False
        
        # Peak hours: 7-9 AM, 4-6 PM
        return (7 <= hour <= 9) or (16 <= hour <= 18)
    
    def get_passenger_statistics(self) -> Dict[str, Any]:
        """Get current passenger statistics."""
        total_generated = self.passenger_counter
        currently_active = len(self.active_passengers)
        total_batches = len(self.generated_batches)
        
        # Trip purpose breakdown
        purpose_counts = {}
        for passenger in self.active_passengers.values():
            purpose = passenger.trip_purpose
            purpose_counts[purpose] = purpose_counts.get(purpose, 0) + 1
        
        # Recent activity
        recent_batches = self.generated_batches[-10:] if self.generated_batches else []
        recent_boarding = sum(batch.total_boarding for batch in recent_batches)
        recent_alighting = sum(batch.total_alighting for batch in recent_batches)
        
        return {
            "total_passengers_generated": total_generated,
            "currently_active_passengers": currently_active,
            "total_batches_generated": total_batches,
            "passenger_limit": self.max_total_passengers,
            "capacity_utilization": (currently_active / self.max_total_passengers) * 100,
            "trip_purpose_breakdown": purpose_counts,
            "recent_boarding_count": recent_boarding,
            "recent_alighting_count": recent_alighting
        }
    
    def cleanup_old_passengers(self, max_age_minutes: int = 120) -> int:
        """Clean up passengers that have been in system too long."""
        current_time = datetime.datetime.now()
        cutoff_time = current_time - datetime.timedelta(minutes=max_age_minutes)
        
        expired_ids = []
        for passenger_id, passenger in self.active_passengers.items():
            if passenger.timestamp < cutoff_time:
                expired_ids.append(passenger_id)
        
        for passenger_id in expired_ids:
            del self.active_passengers[passenger_id]
        
        if expired_ids:
            print(f"ðŸ§¹ Cleaned up {len(expired_ids)} expired passengers")
        
        return len(expired_ids)
    
    def reset_simulation(self) -> None:
        """Reset the passenger generation system."""
        self.passenger_counter = 0
        self.generated_batches.clear()
        self.active_passengers.clear()
        print("ðŸ”„ Passenger generation system reset")


# Global instance
passenger_generation_engine = PassengerGenerationEngine()