/**
 * Route Queries
 * 
 * GraphQL queries for route data from Strapi
 * 
 * ðŸš¨ CRITICAL: Route geometry from Strapi is FRAGMENTED
 * Read ROUTE_GEOMETRY_BIBLE.md for proper geometry handling
 */

import { gql } from 'urql';

/**
 * Fragment for basic route information
 * 
 * NOTE: geometry field in Strapi is fragmented/incomplete
 * For full route geometry, use GeoJSON files instead
 */
export const ROUTE_BASIC_FRAGMENT = gql`
  fragment RouteBasic on Route {
    documentId
    short_name
    long_name
    description
    color
    route_type
  }
`;

/**
 * Query to get all routes (list view)
 * 
 * Use for: Route browser, route selection
 * Does NOT include geometry (intentionally - see ROUTE_GEOMETRY_BIBLE.md)
 */
export const GET_ROUTES_QUERY = gql`
  ${ROUTE_BASIC_FRAGMENT}
  
  query GetRoutes($limit: Int, $start: Int, $sort: [String]) {
    routes(
      pagination: { limit: $limit, start: $start }
      sort: $sort
    ) {
      ...RouteBasic
    }
  }
`;

/**
 * Query to get a single route by ID
 * 
 * âš ï¸ WARNING: The 'geometry' field is fragmented in database
 * For complete route geometry (e.g., Route 1 = 13.347 km, 418 points),
 * fetch from GeoJSON endpoint instead
 */
export const GET_ROUTE_QUERY = gql`
  ${ROUTE_BASIC_FRAGMENT}
  
  query GetRoute($documentId: ID!) {
    route(documentId: $documentId) {
      ...RouteBasic
      createdAt
      updatedAt
    }
  }
`;

/**
 * Query to get a route and its route_shapes -> shapes geometry via Strapi GraphQL.
 *
 * We keep route fields in the route result and fetch the GTFS-style geometry
 * from the `routeShapes` collection (filtering by `route_id`, which in our
 * dataset holds the route short name). For each routeShape we request the
 * linked `shape` relation (shape points) and the essential point fields.
 *
 * Note: Strapi may return routeShapes as an array and the relation `shape`
 * may require the GraphQL server to expose/populate it; this query works
 * against the Strapi GraphQL schema generated in this repo (use in Altair).
 */
export const GET_ROUTE_WITH_SHAPES_QUERY = gql`
  ${ROUTE_BASIC_FRAGMENT}

  query GetRouteWithShapes($documentId: ID!, $routeShortName: String!, $limit: Int = 1000) {
    route(documentId: $documentId) {
      ...RouteBasic
      createdAt
      updatedAt
    }

    routeShapes(filters: { route_id: { eq: $routeShortName } }, pagination: { limit: $limit }, sort: ["route_shape_id:asc"]) {
      route_shape_id
      shape_id
      is_default
      variant_code
    }
  }
`;

/**
 * Query to get route by short_name (route code)
 * 
 * Use for: Looking up routes by user-friendly code (e.g., "1", "1A")
 */
export const GET_ROUTE_BY_CODE_QUERY = gql`
  ${ROUTE_BASIC_FRAGMENT}
  
  query GetRouteByCode($shortName: String!) {
    routes(filters: { short_name: { eq: $shortName } }) {
      ...RouteBasic
    }
  }
`;

/**
 * Query to search routes by name
 * 
 * Use for: Route search functionality
 */
export const SEARCH_ROUTES_QUERY = gql`
  ${ROUTE_BASIC_FRAGMENT}
  
  query SearchRoutes($search: String!, $limit: Int = 10) {
    routes(
      filters: {
        or: [
          { short_name: { containsi: $search } }
          { long_name: { containsi: $search } }
        ]
      }
      pagination: { limit: $limit }
    ) {
      ...RouteBasic
    }
  }
`;

/**
 * TypeScript types for route queries
 * 
 * These will be auto-generated by GraphQL Code Generator
 * but are provided here for reference
 */

export interface Route {
  documentId: string;
  short_name: string;
  long_name?: string;
  description?: string;
  color?: string;
  route_type?: number | null;
  createdAt?: string;
  updatedAt?: string;
}

export interface GetRoutesQueryVariables {
  limit?: number;
  start?: number;
  sort?: string[];
}

export interface GetRoutesQueryResult {
  routes: Route[];
}

export interface GetRouteQueryVariables {
  documentId: string;
}

export interface GetRouteQueryResult {
  route: Route;
}

export interface SearchRoutesQueryVariables {
  search: string;
  limit?: number;
}

export interface SearchRoutesQueryResult {
  routes: Route[];
}
